diff --git a/CMakeLists.txt b/CMakeLists.txt
index b5a65bf..eb87c86 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,6 +1,7 @@
 cmake_minimum_required (VERSION 2.8.0)
 project (FonefiveFS)
 
+
 set(CMAKE_OSX_SYSROOT "/") # Mac users will thank me
 #set(CMAKE_VERBOSE_MAKEFILE ON)
 set(CMAKE_COLOR_MAKEFILE ON)
@@ -12,14 +13,14 @@ find_library(blockstore_lib block_store)
 #find_library(bitmap_lib bitmap)
 #find_library(dynarray_lib dyn_array)
 
-message(FATAL_ERROR "Copy your selected spec to include/${PROJECT_NAME}.h and delete this line!")
+#message(FATAL_ERROR "Copy your selected spec to include/${PROJECT_NAME}.h and delete this line!")
 
 add_library(${PROJECT_NAME} SHARED src/${PROJECT_NAME}.c)
 target_link_libraries(${PROJECT_NAME} ${blockstore_lib}) # Add other libs if you need them
 set_target_properties(${PROJECT_NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON)
 
 install(TARGETS ${PROJECT_NAME} DESTINATION lib)
-install(FILES include/${PROJECT_NAME}.h DESTINATION include)
+install(FILES include/FonefiveFS_basic.h DESTINATION include)
 
 add_executable(${PROJECT_NAME}_tester test/test.c)
 target_link_libraries(${PROJECT_NAME}_tester ${blockstore_lib}) # Don't forget to add them here, too!
diff --git a/include/FonefiveFS_basic.h b/include/FonefiveFS_basic.h
index ea7d234..94f5c09 100644
--- a/include/FonefiveFS_basic.h
+++ b/include/FonefiveFS_basic.h
@@ -3,21 +3,74 @@
 #include <time.h>
 #include <stdio.h>
 #include <block_store.h>
+#include <inttypes.h>
 // Probably other things
 
-typedef struct F15FS F15FS_t;
+
 
 // Enum to differentiate between different kinds of files
 typedef enum {
     REGULAR = 0x01, DIRECTORY = 0x02
 } ftype_t;
 
-// They are what they sound like, the max filename (not counting terminator)
-// and the number of things a directory can contain
-// Have to be exposed in the header for the record structure, which is annoying
-// But the other option is to add more functions to parse and handle that struct
+
+//yea i think #defines are super cool, so I only program using them
+//there are so many I make the names self explanitory to avoid commenting 
+//each one
+#define BLOCK_SIZE 1024
 #define FNAME_MAX 47
 #define DIR_REC_MAX 20
+#define INODE_BLOCK_OFFSET 8
+#define INODE_BLOCK_TOTAL 32
+#define DATA_BLOCK_MAX 65536
+#define DATA_BLOCK_OFFSET (INODE_BLOCK_OFFSET + INODE_BLOCK_TOTAL)
+
+//#define BLOCK_IDX_VALID(block_idx) ((block_idx) >= DATA_BLOCK_OFFSET && (block_idx) < DATA_BLOCK_MAX)
+#define DIRECT_TOTAL 6
+
+#define INDIRECT_TOTAL (BLOCK_SIZE / sizeof(block_ptr_t))
+
+#define DBL_INDIRECT_TOTAL (INDIRECT_TOTAL * INDIRECT_TOTAL)
+
+#define FILE_SIZE_MAX ((DIRECT_TOTAL + INDIRECT_TOTAL + DBL_INDIRECT_TOTAL) * BLOCK_SIZE)
+
+#define CURR_BLOCK_INDEX(size) (((size)+1) / BLOCK_SIZE)
+
+#define BLOCKS_NEEDED(size) (((size)+(BLOCK_SIZE-1))/BLOCK_SIZE)
+
+#define OFFSET_IN_BLOCK(size) ((size) % BLOCK_SIZE)
+
+#define BLOCK_IDX_VALID(block_idx) ((block_idx) >= DATA_BLOCK_OFFSET && (block_idx) < DATA_BLOCK_MAX)
+
+#define INCREMENT_VOID_PTR(v_ptr, increment) (((uint8_t *)v_ptr) + (increment))
+
+
+
+
+typedef uint8_t inode_ptr_t;
+typedef uint32_t block_ptr_t;
+
+//metadata for the inodes
+typedef struct metaData{
+    ftype_t filetype;
+    //1 means
+    char inUse;
+    uint32_t size;
+	char placeholder[38];
+} inode_meta_data_t;
+
+//the individuale inodes
+typedef struct iNode {
+	char fname[FNAME_MAX+1];
+	inode_meta_data_t metaData;
+	uint32_t data_ptrs[8];
+} iNode_t;
+
+//set up the file system structure
+typedef struct F15FS {
+	block_store_t *bs;
+	iNode_t inodeTable[256];
+} F15FS_t;
 
 // It's a directory entry. Won't really be used internally
 typedef struct {
@@ -32,6 +85,37 @@ typedef struct dir_rec {
     dir_entry_t contents[DIR_REC_MAX];
 } dir_rec_t;
 
+
+//for dir block data/////////////////
+//the entry that holds the filename and inode ptr, could be a directory
+typedef struct {
+    char filename[FNAME_MAX+1];
+    ftype_t ftype;
+    inode_ptr_t inode;
+}dir_block_entry_t;
+
+//metadata for the directory itsself
+typedef struct {
+    uint32_t size;
+    char filler[36];
+} dir_meta_t;
+//the actuall entry put onto the block itself
+typedef struct {
+    dir_meta_t metaData;
+    dir_block_entry_t entries[DIR_REC_MAX];
+} dir_block_t;
+//////////////////////////////////////
+
+
+typedef struct {
+    uint8_t found;
+    inode_ptr_t inode;
+    inode_ptr_t parentDir;
+}search_dir_t;
+
+typedef struct{
+    block_ptr_t direct_ptr[32];
+}indirect_block_t;
 ///
 /// Creates a new F15FS file at the given location
 /// \param fname The file to create (or overwrite)
@@ -40,6 +124,128 @@ typedef struct dir_rec {
 int fs_format(const char *const fname);
 
 ///
+/// sets up a block as a new dir
+/// \param bs The blockstore to set it up on
+/// \return the pos of the new dir, <0 for erros
+///
+block_ptr_t setUpDirBlock(block_store_t* bs);
+
+///
+/// allocates room for the inodetable in the bs passed in
+/// \param bs The block store to be allocated
+/// \return <=0 for errors otherwiase success
+///
+int allocateInodeTableInBS(block_store_t* bs);
+
+///
+/// pulls the inode table from bs into memory
+/// \param fs the filesystem to pull the inodetable into
+/// \return >0 for success otherwise erros
+///
+int getiNodeTableFromBS(F15FS_t* fs);
+
+///
+/// flushed the inodetable to the blocksotre of the fs
+/// \param fs the filesytsme to flush the inodetable from
+/// \return >0 for success otherwise erros
+///
+int flushiNodeTableToBS(F15FS_t* fs);
+
+
+///
+/// finds empty node in the inode table
+/// \param fs the filesytem's inode table to search
+/// \return inode index or -1 on error
+///
+int findEmptyInode(F15FS_t *const fs);
+
+///
+/// searches directory for fname
+/// \param fs current file system
+/// \param fname to search the directry for 
+/// \param blockNum the block where the directory is
+/// \param output param to put the found inode index
+/// \return 0 for not found, 1 for found <0 for error
+///
+int searchDir(F15FS_t *const fs, char* fname, block_ptr_t blockNum, inode_ptr_t* inodeIndex);
+
+///
+/// frees the dyn filepath created
+/// \param pathList the malloced array with the path lists
+/// \return <0 for errors
+///
+int freeFilePath(char*** pathList);
+
+///
+/// gets inode from a giving pathlist
+/// \param fs current filesystem
+/// \param pathlist: pathlist for the file or dir to retrieve
+/// \param searchOutParams: output params to put the information
+/// \return <0 for errors 1 for suscess
+///
+int getInodeFromPath(F15FS_t *const fs, char** pathList, search_dir_t* searchOutParams);
+
+///
+/// parses string to file path list
+/// \param filepath: string with the file path
+/// \param pathLIstOutput: the outputed pathlist
+/// \return <0 for erros 1 for success
+///
+int parseFilePath(const char *const filePath, char*** pathListOutput);
+
+///
+/// adds a file to a directory
+/// \param fs current file system
+/// \param fname: name of file to add
+/// \param fileinode: index of file's inode
+/// \param dirinode: inode to the dir where to add the file
+/// \param ftype: filetype of the file
+/// \return <0 for error 1 for success
+///
+int addFIleToDir(F15FS_t *const fs, const char *const fname, inode_ptr_t fileInode, inode_ptr_t dirInode, ftype_t ftype);
+
+///
+/// write date to an indirect block
+/// \param fs current file system
+/// \param dataLeftToWrite the data amount that still needs to be writen
+/// \param data the data to be writen
+/// \param nbytes to total number of bytes to write
+/// \param neededToAllocate tell if its nesseary to allocate new blocks or write over the old ones
+/// \param blocksUsed finding the index fo the block to start wirting on
+/// \param indirectBLockId the id of the inderect block to write to 
+/// \return the indirectblockid, uint32_t_MAX for error
+/// 
+block_ptr_t writeIndirectBlock(F15FS_t *const fs,size_t *dataLeftTOWrite,const void *data,size_t nbytes,size_t needToAllocate,size_t blocksUsed,block_ptr_t indirectBlockId);
+
+///
+/// write date to an direct block
+/// \param fs current file system
+/// \param dataLeftToWrite the data amount that still needs to be writen
+/// \param data the data to be writen
+/// \param offset offest to write to the block
+/// \param nbytes to total number of bytes to write
+/// \param neededToAllocate tell if its nesseary to allocate new blocks or write over the old ones
+/// \param BLockId the id of the inderect block to write to 
+/// \return the indirectblockid, uint32_t_MAX for error
+/// 
+block_ptr_t writeDirectBLock(F15FS_t *const fs,size_t *dataLeftTOWrite,const void *data, size_t offset,size_t nbytes,size_t *needToAllocate, block_ptr_t blockId);
+
+
+///
+/// read from a direct block
+/// \param fs current file system
+/// \param dataLeftToread the bytes that still have to be read from teh file
+/// \param data the buffer to put the read in data
+/// \param offset the amount to offset the blcok when reading from it
+/// \param nbyte the total amount of bytes to read
+/// \param blockId the block id to read from
+/// \return <0 for errors
+///
+int readDirectBLock(F15FS_t *const fs,size_t *dataLeftTORead,const void *data, size_t offset, size_t nbyte, size_t blockId);
+
+
+
+///
 /// Mounts the specified file and returns an F15FS object
 /// \param fname the file to load
 /// \return An F15FS object ready to use, NULL on error
@@ -69,7 +275,7 @@ int fs_create_file(F15FS_t *const fs, const char *const fname, const ftype_t fty
 /// \param records the record object to fill
 /// \return 0 on success, < 0 on error
 ///
-int fs_get_dir(const F15FS_t *const fs, const char *const fname, dir_rec_t *const records);
+int fs_get_dir(F15FS_t *const fs, const char *const fname, dir_rec_t *const records);
 
 ///
 /// Writes nbytes from the given buffer to the specified file and offset
diff --git a/src/FonefiveFS.c b/src/FonefiveFS.c
index 3b8d171..6ede75e 100644
--- a/src/FonefiveFS.c
+++ b/src/FonefiveFS.c
@@ -1,2 +1,809 @@
-#include "../include/FonefiveFS.h"
+#include "../include/FonefiveFS_basic.h"
+
+#define BLOCK_SIZE 1024
+#define ROOT_INODE 0
+
+
+
+int fs_format(const char *const fname){
+	//param check
+	if(fname && fname != NULL && strcmp(fname,"") != 0){
+		//create the blockstore
+		block_store_t* bs = block_store_create();
+		if(bs){
+			//use util funt o allocate all the spaces needed in it.
+			//really just to make sure we set the front blocks to used
+			//in the bitmap for the inode table so they can't be allocated as data blcoks
+			if(allocateInodeTableInBS(bs) >= 0){
+
+                //write the block store to the file
+                block_store_link(bs, fname);
+
+                return 0;
+            }
+
+		}
+	}
+	return -1;
+}
+
+
+block_ptr_t setUpDirBlock(block_store_t* bs){
+	//param check
+	if(bs){
+		//declare the new dir
+	    dir_block_t newDir;
+
+	    //set the size of its contents to zero
+	    newDir.metaData.size = 0;
+
+	    //declare it pos
+	    block_ptr_t dirBlockPos;
+
+	    //get the next free block in the blockstore
+	    if((dirBlockPos = block_store_allocate(bs))){
+	    	//write the data of the dir to the block and get teh pos to put in the inode table
+	    	if(block_store_write(bs, dirBlockPos, &newDir, BLOCK_SIZE, 0) == BLOCK_SIZE){
+	    		return dirBlockPos;
+	    	}
+
+	    }
+	}
+    return -1;
+}
+
+int allocateInodeTableInBS(block_store_t* bs){
+	//param check,
+    if(bs){
+
+		//declare i because c just isn't as cool as c++ with declaring in the loop
+		size_t i = 0;
+        //allocate the room for the inode table
+		for(i=8; i<41; i++){
+			if(!block_store_request(bs,i)){
+				return -1;
+			}
+		}
+
+		//create a root inode
+		iNode_t rootNode;
+
+        //set root filename as '/'
+		rootNode.fname[0] = '/';
+
+        //set the file type to a directory
+        rootNode.metaData.filetype = DIRECTORY;
+        rootNode.metaData.inUse = 1;
+
+		//allocate the root directory node and check it worked
+		if((rootNode.data_ptrs[0] = setUpDirBlock(bs)) < 0){
+            return -1;
+        }
+
+        //write root inode to the blockstore
+        if(block_store_write(bs, 8, &rootNode, 128, 0) == 128){
+			return 1;
+		}
+		return -11;
+
+	}
+	return -1;
+}
+
+
+int flushiNodeTableToBS(F15FS_t* fs){
+	//I'm really lovin all these param checks
+	if(fs && fs->bs != NULL){
+		//I think size_t is some cool stuff, you know causes it looks special
+		size_t i = 8;
+		//another kilobyte of fun
+		char buffer[BLOCK_SIZE];
+		//index mapping var to go from i to the correct index of the inodetable
+		int startingPos = 0;
+		for(i = 8; i < 41; i++){
+			//increment the mapping var
+			startingPos = (i-8)*8;
+			//take the memory to a buffer before we write to the table in casue of
+			// some funny bussiness in the blockstore
+			if(memcpy(&buffer,(fs->inodeTable+startingPos),BLOCK_SIZE) != NULL){
+				//write our stuff to the block store
+				if(block_store_write(fs->bs,i,&buffer,BLOCK_SIZE,0) != BLOCK_SIZE){
+					return 0;
+				}
+			}
+			else{
+				return 0;
+			}
+		}
+		return 1;
+	}
+	return 0;
+
+}
+
+int getiNodeTableFromBS(F15FS_t* fs){
+	//usual param checks
+	if(fs){
+		//starting at the 8th block in the blockstore
+		size_t i = 8;
+		//set up the buffer to be 1 kilobyte
+		uint8_t buffer[BLOCK_SIZE];
+		//create a maping var to get the index of the inodetable
+		int startingPos = 0;
+		for(i = 8; i < 40; i++){
+			//increment the index mapper
+			startingPos = (i-8)*8;
+			//reak a block from the bs
+			if(block_store_read(fs->bs,i,&buffer,BLOCK_SIZE,0) == BLOCK_SIZE){
+				//put the contents into the fs inode table
+				if(memcpy((fs->inodeTable+startingPos),&buffer,BLOCK_SIZE) == NULL){
+					return 0;
+				}
+			}
+			else{
+				return 0;
+			}
+		}
+		return 1;
+	}
+	return 0;
+}
+
+
+F15FS_t *fs_mount(const char *const fname){
+	//check params, having to check for weird things
+	if(fname && strcmp(fname,"") != 0){
+		//create the filesytem struct
+		F15FS_t* fs = (F15FS_t*)malloc(sizeof(F15FS_t));
+		if(fs){
+			//import the blockstore from the file
+			if((fs->bs = block_store_import(fname)) != NULL){
+				//pull the inode table into memory
+				if(getiNodeTableFromBS(fs)){
+					return fs;
+				}
+			}
+		}
+	}
+	return NULL;
+}
+
+
+
+int fs_unmount(F15FS_t *fs){
+	//check params
+	if(fs && fs->inodeTable && fs->bs){
+		//flush the inode table into the blockstore
+		if(flushiNodeTableToBS(fs)){
+			//flush the blockstore to the file
+			block_store_flush(fs->bs);
+			if(block_store_errno() == BS_OK){
+				//free the blockstore
+				block_store_destroy(fs->bs,BS_NO_FLUSH);
+				//free the file system pointer
+				free(fs);
+				return 0;
+			}
+
+		}
+	}
+	return -1;
+}
+
+
+
+int findEmptyInode(F15FS_t *const fs){
+    //paraam check
+    if(fs){
+        int i = 0;
+        //search through to find first not used inode in table
+        for(i = 0; i < 256; i++){
+            if(((int)fs->inodeTable[i].metaData.inUse) != 1){
+                return i;
+            }
+        }
+    }
+    return -1;
+}
+
+//0 for not there -1 for actual error 1 for found
+int searchDir(F15FS_t *const fs, char* fname, block_ptr_t blockNum, inode_ptr_t* inodeIndex){
+    //param check
+    if(fs && fname && fname[0]){
+	    dir_block_t dir;
+	    // read dir from the blockstore
+	    if(block_store_read(fs->bs,blockNum,&dir,BLOCK_SIZE,0) == BLOCK_SIZE){
+	        int i = 0;
+	        //loop through comparing the filename to see if its in the dir
+	        for(i = 0; i < dir.metaData.size; i++){
+	            if(i > 20){
+	            	return -1;
+	            }
+	            if(strcmp(dir.entries[i].filename,fname) == 0){
+	                //found it, so return 
+	                *inodeIndex = dir.entries[i].inode;
+	                return 1;
+	            }
+	        }
+	        return 0;
+    	}
+    	fprintf(stderr,"Failed to read from hd in search directoy\n");
+    	exit(-1);
+    }
+    fprintf(stderr,"Failed param check while searching the directory\n");
+    return -1;
+}
+
+int freeFilePath(char*** pathList){
+    //get the size of the list, i put it at the front
+    int listSize = (int)*(*pathList)[0];
+    int i = 0;
+    // free all the strings 
+    for(i = 0; i < listSize + 1; i++){
+        free((*pathList)[i]);
+        (*pathList)[i] = NULL;
+    }
+    //free the list itself
+    free(*pathList);
+    *pathList = NULL;
+    return 1;
+}
+
+
+// 1 found 0 not found but still filled <0 error
+int getInodeFromPath(F15FS_t *const fs, char** pathList, search_dir_t* searchOutParams){
+    if(fs && pathList && searchOutParams){
+        //get list size 
+        int listSize = (int)*pathList[0];
+
+
+        int i = 1;
+        //start it at the root node
+        inode_ptr_t currInode = ROOT_INODE;
+        inode_ptr_t parentInode = ROOT_INODE;
+        int result = 0;
+
+        //loop through each filename in the list
+        for(i = 1; i < listSize + 1; i++){
+            result = searchDir(fs, pathList[i], fs->inodeTable[parentInode].data_ptrs[0], &currInode);
+            // if the filename was not found
+            if(result == 0){
+                //not found but at the end of list, populate with parent direct
+                //for creating a file in that spot
+                if((listSize - i) == 0){
+                    searchOutParams->found = 0;
+                    searchOutParams->parentDir = parentInode;
+                    return 0;
+                }
+                else{
+                    //bad path
+                    searchOutParams->found = 0;
+                    fprintf(stderr,"bad path 1\n");
+                    return -1;
+                }
+
+
+            }
+            //if the filename was found 
+            else if(result == 1){
+            	//keep searching
+                if((listSize - i) != 0 && fs->inodeTable[currInode].metaData.filetype == DIRECTORY){
+                    parentInode = currInode;
+                    continue;
+                }
+                //we just ended with a dir, works good if i want to read a dir
+                else if((listSize - i) == 0 && fs->inodeTable[currInode].metaData.filetype == DIRECTORY){
+                    //can't end it path with directory
+                    searchOutParams->found = 1;
+                    searchOutParams->parentDir = parentInode;
+                    searchOutParams->inode = currInode;
+                    return -2;
+                }
+                else if((listSize - i) != 0 && fs->inodeTable[currInode].metaData.filetype == REGULAR){
+                    //can't have file not at end of path
+                    return -3;
+                }
+                //found a file and its at the end o the list
+                else if((listSize - i) == 0 && fs->inodeTable[currInode].metaData.filetype == REGULAR){
+                    searchOutParams->found = 1;
+                    searchOutParams->parentDir = parentInode;
+                    searchOutParams->inode = currInode;
+                    return 1;
+                }
+            }
+
+
+         }
+         return -1;
+
+    }
+    //bad params
+    fprintf(stderr,"bad params while getting inode\n");
+    return -1;
+}
+
+int parseFilePath(const char *const filePath, char*** pathListOutput){
+    if(filePath && strcmp(filePath,"") != 0){
+        //convert the filepath to a non const to tokenize	
+        char* nonConstFilePath = malloc(strlen(filePath)+1);
+        if(!nonConstFilePath){
+            return -1;
+        }
+        strcpy(nonConstFilePath,filePath);
+        
+        char* temp = nonConstFilePath;
+        char** pathList = NULL;
+        int count = 0;
+        //set the delim for the string tok 
+        const char *delim = "/";
+        char* token;
+
+        //count how many files we have in the path to know how much to malloc
+        while(*temp){
+            if(*temp == '/'){
+                count++;
+            }
+            temp++;
+        }
+        //check if its jsut the root dir
+        if(count == 0){
+            //theres only a file or directory name so just add the count
+            //and whats in there to one
+            if((pathList = (char**)malloc(sizeof(char*)*2)) != NULL){
+                //malloc the individual strings
+                if((pathList[0] = (char*)malloc(sizeof(char))) != NULL){
+                    *pathList[0] = 1;
+                    pathList[1] = nonConstFilePath;
+                    *pathListOutput = pathList;
+                    return 1;
+                }
+                free(pathList);
+            }
+            free(nonConstFilePath);
+            fprintf(stderr, "error during mallocing\n");
+            return -1;
+        }else{
+            //create string array with right size plus one to add the size in
+            if((pathList = (char**)malloc(sizeof(char*)*(count+1))) == NULL){
+                free(nonConstFilePath);
+                fprintf(stderr, "error during mallocing\n");
+                return -1;
+            }
+
+            if((pathList[0] = malloc(sizeof(char))) == NULL){
+                free(nonConstFilePath);
+                free(pathList);
+                fprintf(stderr, "error during mallocing\n");
+                return -1;
+            }
+
+            //put the length at the begging
+            *pathList[0] = count;
+
+            token = strtok(nonConstFilePath,delim);
+
+            int i = 1;
+            //loop through the toekens to be able to work
+            while(token != NULL){
+                if(strlen(token) > FNAME_MAX){
+                    for(i = i - 1;i >= 0; i--){
+                        free(pathList[i]);
+                    }
+                    //free everything so far if we get an error
+                    free(pathList);
+                    free(nonConstFilePath);
+                    fprintf(stderr,"File or Dir name to long\n");
+                    return -1;
+                }
+                //if all good malloc some stuff
+                if((pathList[i] = (char*)malloc(strlen(token) + 1)) == NULL){
+                    for(;i >= 0; i--){
+                        free(pathList[i]);
+                    }
+                    free(pathList);
+                    free(nonConstFilePath);
+                    fprintf(stderr, "Error during mallocing\n");
+                    return -1;
+                }
+                //copy the token into the newly allocated array
+                strcpy(pathList[i],token);
+
+                token = strtok(NULL,delim);
+                i++;
+            }
+            free(nonConstFilePath);
+            *pathListOutput = pathList;
+            return 1;
+
+        }
+    }
+    fprintf(stderr, "bad params\n");
+    return -1;
+}
+
+int addFIleToDir(F15FS_t *const fs, const char *const fname, inode_ptr_t fileInode, inode_ptr_t dirInode, ftype_t ftype){
+    //param check
+    if(fs && fname && strcmp(fname,"") != 0 && dirInode >= 0){
+        //set dir block to read into 
+        dir_block_t dir;
+        //read dir from blockstore
+        if(block_store_read(fs->bs,fs->inodeTable[dirInode].data_ptrs[0],&dir,BLOCK_SIZE,0) == BLOCK_SIZE){
+            if(dir.metaData.size < DIR_REC_MAX && strlen(fname) <= FNAME_MAX){
+                //add everythign about the file to the dir
+                dir.entries[dir.metaData.size].inode = fileInode;
+                dir.entries[dir.metaData.size].ftype = ftype;
+                strcpy(dir.entries[dir.metaData.size].filename, fname);
+                //update the size of the dir
+                dir.metaData.size++;
+                //write the block back to the store
+                if(block_store_write(fs->bs,fs->inodeTable[dirInode].data_ptrs[0],&dir,BLOCK_SIZE,0) == BLOCK_SIZE){
+                    return 1;
+                }
+                fprintf(stderr,"failed to write to block afto din\n");
+            }
+            fprintf(stderr,"couldn't add to dir1\n");
+            return -1;
+        }
+        fprintf(stderr,"coulnd't add to dir 2\n");
+        return -1;
+    }
+    fprintf(stderr,"bad params addto din\n");
+    return -1;
+}
+
+
+int fs_create_file(F15FS_t *const fs, const char *const fname, const ftype_t ftype){
+    //param check
+    if(fs && fname && strcmp(fname,"") != 0 && strcmp(fname,"/") != 0&& ftype){
+        //get empty inode
+        int emptyiNodeIndex = findEmptyInode(fs);
+        if(emptyiNodeIndex < 0){
+        	fprintf(stderr, "No empty Inodes\n");
+        	return -1;
+        }
+        char **pathList = NULL;
+        int listSize = 0;
+        search_dir_t dirInfo;
+        //parse filepath
+        if(parseFilePath(fname,&pathList) > 0){
+            //get the inode, shouldn't be able to find it 
+            if(getInodeFromPath(fs,pathList, &dirInfo) == 0){
+                listSize = (int)*pathList[0];
+                //set the use byte
+                fs->inodeTable[emptyiNodeIndex].metaData.inUse = 1;
+                fs->inodeTable[emptyiNodeIndex].metaData.filetype = ftype;
+
+                //add the fname to the inode
+                strcpy(fs->inodeTable[emptyiNodeIndex].fname,pathList[listSize]);
+                if(addFIleToDir(fs, pathList[listSize], emptyiNodeIndex,dirInfo.parentDir, ftype) < 0){
+                	fprintf(stderr, "Not able to add file to Directory\n");
+                	return -1;
+                }
+                //if its a dir set it up in the blockstore
+                if(ftype == DIRECTORY){
+                    if((fs->inodeTable[emptyiNodeIndex].data_ptrs[0] = setUpDirBlock(fs->bs)) > 0){
+                        return 0;
+                    }
+                }else{
+                    //no need to do anything if its just a file, need to actual have things be writen
+                    return 0;
+                }
+            }
+        }
+    }
+    fprintf(stderr, "Bad params when creating the file\n");
+    return -1;
+}
+
+
+int fs_get_dir(F15FS_t *const fs, const char *const fname, dir_rec_t *const records){
+    if(fs && fname && fname[0] && records){
+        char** pathList = NULL;
+        search_dir_t dirInfo;
+        dir_block_t dir;
+        
+        //this is kind of hacky but i'm running out of time
+        //and this is the first time I have ever used a goto ever
+        if(strcmp(fname,"/") == 0){
+        	dirInfo.inode = 0;
+        	goto RootSearch; 
+        }
+        //parse filepath
+        if(parseFilePath(fname, &pathList) > 0){
+            //get the indoe for the file or dir in this case
+            if(getInodeFromPath(fs,pathList,&dirInfo) == -2){
+                RootSearch:
+                //read in teh dir
+                if(block_store_read(fs->bs,fs->inodeTable[dirInfo.inode].data_ptrs[0],&dir,BLOCK_SIZE,0) == BLOCK_SIZE){
+                    int i = 0;
+                    records->total = dir.metaData.size;
+                    //add all data to the records 
+                    for(i = 0; i < dir.metaData.size; i++){
+                        strcpy(records->contents[i].fname, dir.entries[i].filename);
+                        records->contents[i].ftype = dir.entries[i].ftype;
+                    }
+                    return 0;
+                }
+            }
+        }
+
+    }
+    return -1;
+}
+
+block_ptr_t writeDirectBLock(F15FS_t *const fs,size_t *dataLeftTOWrite, const void *data, size_t offset,size_t nbyte,size_t *needToAllocate, block_ptr_t blockId){
+    if(fs && *dataLeftTOWrite > 0 && data && nbyte > 0){
+        size_t dataOffset = nbyte - *dataLeftTOWrite;
+        size_t bytesToWrite = 0;
+        if(blockId > 65232){
+        	return (uint32_t)-1;
+        }
+        //if we are overiding current data so no need to allocate
+        if(BLOCK_IDX_VALID(blockId) && needToAllocate > 0){
+            if(*dataLeftTOWrite < BLOCK_SIZE - offset){
+                bytesToWrite = *dataLeftTOWrite;
+            }
+            else{
+                bytesToWrite = BLOCK_SIZE - offset;
+            }
+            //write the data to the fs
+            if(block_store_write(fs->bs,blockId,INCREMENT_VOID_PTR(data,dataOffset),bytesToWrite,offset) == bytesToWrite){
+                *dataLeftTOWrite -= bytesToWrite;
+                *needToAllocate -= bytesToWrite;
+                return blockId;
+            }
+            fprintf(stderr,"failed to write to hd when writing direct block\n");
+            exit(-1);
+        }
+        else{
+        	//we need to allocate becasue we are writing new data
+            blockId = block_store_allocate(fs->bs);
+
+            if(*dataLeftTOWrite < BLOCK_SIZE - offset){
+                bytesToWrite = *dataLeftTOWrite;
+            }
+            else{
+                bytesToWrite = BLOCK_SIZE - offset;
+            }
+            //write the data to the blockstore
+            if(block_store_write(fs->bs,blockId,INCREMENT_VOID_PTR(data,dataOffset),bytesToWrite,offset) == bytesToWrite){
+                *dataLeftTOWrite -= bytesToWrite;
+                return blockId;
+            }
+            fprintf(stderr,"failed to write to hd when writing direct block\n");
+            exit(-1);
+        }
+
+
+    }
+    fprintf(stderr,"Failed params check when writing direct block\n");
+    exit(-1);
+}
+
+block_ptr_t writeIndirectBlock(F15FS_t *const fs,size_t *dataLeftTOWrite,const void *data,size_t nbyte,size_t needToAllocate,size_t blocksUsed,block_ptr_t indirectBlockId){
+    if(fs && *dataLeftTOWrite > 0 && data && nbyte > 0){
+        indirect_block_t indirectBlock;
+        size_t bytesToWrite = 0;
+        size_t i = 0;
+        size_t CurrBlockToWrite = blocksUsed - DIRECT_TOTAL;
+
+        //already alocated
+        if(BLOCK_IDX_VALID(indirectBlockId) && CurrBlockToWrite > 0){
+            //read in the indirect block to get the direct pointers
+            if(block_store_read(fs->bs,indirectBlockId,&indirectBlock,BLOCK_SIZE,0) == BLOCK_SIZE){
+                if(*dataLeftTOWrite < ((INDIRECT_TOTAL - CurrBlockToWrite - 1)*BLOCK_SIZE)){
+                    bytesToWrite = *dataLeftTOWrite;
+                }
+                else{
+                    bytesToWrite = ((INDIRECT_TOTAL - CurrBlockToWrite - 1)*BLOCK_SIZE);
+                }
+                size_t tempBytesToWrite = bytesToWrite;
+                i = CurrBlockToWrite;
+                //loop through to add to the direct blocks, call helper func
+                while(bytesToWrite > 0){
+                    indirectBlock.direct_ptr[i] = writeDirectBLock(fs,&bytesToWrite,data,0,nbyte,0,0);
+                    if(indirectBlock.direct_ptr[i] == (uint32_t)-1){
+                    	return (uint32_t)-1;
+                    }
+                    i++;
+                }
+                *dataLeftTOWrite -= tempBytesToWrite;
+                return indirectBlockId;
+            }
+            fprintf(stderr, "Problem reading indirect block from hd\n");
+            exit(-1);
+        }
+        else{
+        	//the same as above but we now need to allocate everything 
+            if(*dataLeftTOWrite < (INDIRECT_TOTAL*BLOCK_SIZE)){
+                bytesToWrite = *dataLeftTOWrite;
+            }
+            else{
+                bytesToWrite = INDIRECT_TOTAL * BLOCK_SIZE;
+            }
+
+            indirectBlockId = block_store_allocate(fs->bs);
+            size_t tempBytesToWrite = bytesToWrite;
+            while(bytesToWrite > 0){
+                indirectBlock.direct_ptr[i] = writeDirectBLock(fs,&bytesToWrite,data,0,nbyte,0,0);
+                i++;
+            }
+            *dataLeftTOWrite -= tempBytesToWrite;
+            return indirectBlockId;
+        }
+    }
+    fprintf(stderr, "failed param check while writing to indirect block\n");
+    exit(-1);
+}
+
+
+ssize_t fs_write_file(F15FS_t *const fs, const char *const fname, const void *data, size_t nbyte, size_t offset){
+    if(fs && fname && fname[0] && data && nbyte > 0 && (offset + nbyte) < FILE_SIZE_MAX){
+        char **pathList = NULL;
+        //int listSize = 0;
+        size_t currFileSize = 0;
+        size_t blocksUsed = 0;
+        size_t needToAllocate = 0;
+        size_t dataWriten = 0;
+        //if something goes wrong it wont try and write set to zero
+        size_t dataLeftTOWrite = 0;
+        inode_ptr_t currFileIndex = 0;
+        search_dir_t dirInfo;
+
+        //parse file path
+        if(parseFilePath(fname,&pathList) > 0){
+        	//get inode for the file, it should exisit otherse error
+            if(getInodeFromPath(fs,pathList, &dirInfo) > 0){
+                //set up the
+                // listSize = (int)*pathList[0];
+                currFileIndex = dirInfo.inode;
+                currFileSize = fs->inodeTable[currFileIndex].metaData.size;
+                if(offset > currFileSize){
+                    fprintf(stderr, "Trying to read more data than is in the file\n");
+                    return -1;
+                }
+                //check when its time to start adding new blocks instead of writing over them
+                needToAllocate = currFileSize - offset;
+                dataLeftTOWrite = nbyte;
+                dataWriten = dataLeftTOWrite;
+                while(dataLeftTOWrite != 0){
+                	//printf("data wrirte: %lu\n",dataLeftTOWrite);
+                	blocksUsed = CURR_BLOCK_INDEX(offset);
+                    //its time to read from the direct lbocks
+                    if(blocksUsed >= 0 && blocksUsed < DIRECT_TOTAL){
+                        fs->inodeTable[currFileIndex].data_ptrs[blocksUsed] = writeDirectBLock(fs,&dataLeftTOWrite,data,OFFSET_IN_BLOCK(offset),nbyte,&needToAllocate,fs->inodeTable[currFileIndex].data_ptrs[blocksUsed]);
+                    	offset += (dataWriten - dataLeftTOWrite);
+                    	dataWriten = dataLeftTOWrite;
+                    }
+                    //read from the indirect lbocks
+                    else if(blocksUsed >= DIRECT_TOTAL && blocksUsed < INDIRECT_TOTAL){
+                        fs->inodeTable[currFileIndex].data_ptrs[DIRECT_TOTAL] = writeIndirectBlock(fs,&dataLeftTOWrite,data,nbyte,needToAllocate,blocksUsed,fs->inodeTable[currFileIndex].data_ptrs[DIRECT_TOTAL]);
+                    	offset += (dataWriten - dataLeftTOWrite);
+                    	dataWriten = dataLeftTOWrite;
+                    }
+                    //read from double indirect
+                    else if(blocksUsed >= INDIRECT_TOTAL && blocksUsed < DBL_INDIRECT_TOTAL){
+                        fprintf(stderr,"have not implemented the ability for that big of a file\n");
+                        return -1;
+                        exit(-1);
+                    }
+                    //we messed up man
+                    else{
+                        fprintf(stderr,"file to big after already checked, so pretty weird error\n");
+                        return -1;
+                    }
+                }
+                fs->inodeTable[currFileIndex].metaData.size += nbyte;
+                return nbyte;
+
+            }
+            fprintf(stderr,"Could not find file to write\n");
+            return -1;
+        }
+        fprintf(stderr,"failed to parse filepath\n");
+        return -1;
+    }
+    fprintf(stderr, "bad params while writing\n");
+    return -1;
+}
+
+
+
+
+int readDirectBLock(F15FS_t *const fs,size_t *dataLeftTORead,const void *data, size_t offset, size_t nbyte, size_t blockId){
+	if(fs && *dataLeftTORead > 0 && data && BLOCK_IDX_VALID(blockId)){
+		size_t dataOffset = nbyte - *dataLeftTORead;
+        size_t bytesToRead = 0;
+        //set up the right data to stay in bounds 
+        if(*dataLeftTORead < BLOCK_SIZE - offset){
+            bytesToRead = *dataLeftTORead;
+        }
+        else{
+            bytesToRead = BLOCK_SIZE - offset;
+        }
+        //read the data into the data buffer
+        if(block_store_read(fs->bs,blockId,INCREMENT_VOID_PTR(data,dataOffset),bytesToRead,offset) == bytesToRead){
+            *dataLeftTORead -= bytesToRead;
+            return 1;
+        }
+        fprintf(stderr,"failed to write to hd when writing direct block\n");
+        return -1;
+
+	}
+	fprintf(stderr,"Failed param check while reading direcet block\n");
+	return -1;
+}
+
+
+
+ssize_t fs_read_file(F15FS_t *const fs, const char *const fname, void *data, size_t nbyte, size_t offset){
+	if(fs && fname && fname[0] && data && nbyte > 0){
+		//init vars
+		char **pathList = NULL;
+		search_dir_t dirInfo;
+		size_t dataLeftTORead = 0;
+		size_t currFileSize = 0;
+        size_t blocksUsed = 0;
+        size_t currFileIndex = 0;
+        size_t dataRead = 0;
+
+        //parse the file path
+		if(parseFilePath(fname,&pathList) > 0){
+			//get the indoe, it must exist
+            if(getInodeFromPath(fs,pathList, &dirInfo) > 0){
+            
+            	currFileIndex = dirInfo.inode;
+                currFileSize = fs->inodeTable[currFileIndex].metaData.size;
+                if((offset + nbyte) > currFileSize){
+                    fprintf(stderr, "Trying to read to big of a file\n");
+                    return -1;
+                }
+
+                dataLeftTORead = nbyte;
+                //keep trying as long as there is data to read
+                while(dataLeftTORead != 0){
+                	//printf("data wrirte: %lu\n",dataLeftTOWrite);
+                	blocksUsed = CURR_BLOCK_INDEX(offset);
+                	printf("blocksused = %lu\n",blocksUsed);
+                    //rad from direct pointers
+                    if(blocksUsed >= 0 && blocksUsed < DIRECT_TOTAL){
+                        if(readDirectBLock(fs,&dataLeftTORead,data,OFFSET_IN_BLOCK(offset),nbyte,fs->inodeTable[currFileIndex].data_ptrs[blocksUsed]) < 0){
+                        	fprintf(stderr,"Failed to read direct block while reading\n");
+                        	return -1;
+                        }
+
+                    	offset += (dataRead - dataLeftTORead);
+                    	dataRead = dataLeftTORead;
+                    }
+                    //rad from indirect poiters
+                    else if(blocksUsed >= DIRECT_TOTAL && blocksUsed < INDIRECT_TOTAL){
+                        fprintf(stderr,"Not yet implemented\n");
+                        return -1;
+                     //    if(readIndirectBlock(fs,&dataLeftTORead,data,nbyte,blocksUsed,fs->inodeTable[currFileIndex].data_ptrs[DIRECT_TOTAL]) < 0){
+                     //    	fprintf(stderr,"Failed to read indirect block while reading file\n");
+                     //    }
+                    	// offset += (dataRead - dataLeftTORead);
+                    	// dataRead = dataLeftTORead;
+                    }
+                    //read from double indirect pointers
+                    else if(blocksUsed >= INDIRECT_TOTAL && blocksUsed < DBL_INDIRECT_TOTAL){
+                        fprintf(stderr,"have not implemented the ability for that big of a file\n");
+                        return -1;
+                        exit(-1);
+                    }
+                    else{
+                        fprintf(stderr,"file to big after already checked, so pretty weird error\n");
+                        return -1;
+                    }
+                }
+
+
+            }
+            fprintf(stderr,"Failed to find file while reading\n");
+        }
+        fprintf(stderr,"Failed to parse file path while reading file\n");
+	}	return -1;
+	fprintf(stderr, "Failed params while reading File\n");
+	return -1;
+}
 
diff --git a/src/a.out.dSYM/Contents/Info.plist b/src/a.out.dSYM/Contents/Info.plist
new file mode 100644
index 0000000..3679a65
--- /dev/null
+++ b/src/a.out.dSYM/Contents/Info.plist
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+	<dict>
+		<key>CFBundleDevelopmentRegion</key>
+		<string>English</string>
+		<key>CFBundleIdentifier</key>
+		<string>com.apple.xcode.dsym.a.out</string>
+		<key>CFBundleInfoDictionaryVersion</key>
+		<string>6.0</string>
+		<key>CFBundlePackageType</key>
+		<string>dSYM</string>
+		<key>CFBundleSignature</key>
+		<string>????</string>
+		<key>CFBundleShortVersionString</key>
+		<string>1.0</string>
+		<key>CFBundleVersion</key>
+		<string>1</string>
+	</dict>
+</plist>
diff --git a/src/test.c b/src/test.c
new file mode 100644
index 0000000..286c247
--- /dev/null
+++ b/src/test.c
@@ -0,0 +1,108 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int parseFilePath(const char *const filePath, char** pathListOutput);
+
+int main(){
+
+
+    const char *const path = "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig";
+
+
+
+    char **test = NULL;
+    if(parseFilePath(path, test)){
+
+
+
+        printf("%d\n",(int)(*test[0]));
+        int size = (int)(*test[0]);
+        int i = 1;
+        for(;i<size+1;i++){
+            printf("%s\n",test[i]);
+        }
+    }
+
+    return 0;
+}
+
+int parseFilePath(const char *const filePath, char** pathListOutput){
+    if(filePath && strcmp(filePath,"") != 0){
+        char* nonConstFilePath = malloc(strlen(filePath)+1);
+        if(!nonConstFilePath){
+            return 0;
+        }
+        strcpy(nonConstFilePath,filePath);
+        char* temp = nonConstFilePath;
+        char** pathList = NULL;
+        int count = 0;
+        int i = 1;
+        const char *delim = "/";
+        char* token;
+
+        while(*temp){
+            if(*temp == '/'){
+                count++;
+            }
+            temp++;
+        }
+
+        if(count == 0){
+            //theres only a file or directory name so just add the count
+            //and whats in there to one
+            if((pathList = (char**)malloc(sizeof(char*)*2)) != NULL){
+                if((pathList[0] = (char*)malloc(sizeof(char))) != NULL){
+                    *pathList[0] = 1;
+                    pathList[1] = nonConstFilePath;
+                    pathListOutput = pathList;
+                    return 1;
+                }
+                free(pathList);
+            }
+            free(nonConstFilePath);
+            fprintf(stderr, "error during mallocing\n");
+            return 0;
+        }else{
+            //create string array with right size plus one to add the size in
+            if((pathList = (char**)malloc(sizeof(char*)*(count+1))) == NULL){
+                free(nonConstFilePath);
+                fprintf(stderr, "error during mallocing\n");
+                return 0;
+            }
+
+            if((pathList[0] = malloc(sizeof(char))) == NULL){
+                free(nonConstFilePath);
+                free(pathList);
+                fprintf(stderr, "error during mallocing\n");
+                return 0;
+            }
+
+            //put the length at the begging
+            *pathList[0] = count;
+
+            token = strtok(nonConstFilePath,delim);
+
+
+            while(token != NULL){
+                if((pathList[i] = (char*)malloc(strlen(token))) == NULL){
+                    free(nonConstFilePath);
+                    free(pathList);
+                    fprintf(stderr, "error during mallocing\n");
+                    return 0;
+                }
+
+                strcpy(pathList[i],token);
+
+                token = strtok(NULL,delim);
+                i++;
+            }
+            free(nonConstFilePath);
+            pathListOutput = pathList;
+            return 1;
+
+        }
+    }
+    fprintf(stderr, "bad params\n");
+    return 0;
+}
\ No newline at end of file
diff --git a/test/test.c b/test/test.c
index c5c0351..79a4027 100644
--- a/test/test.c
+++ b/test/test.c
@@ -5,77 +5,237 @@
 #include "../src/FonefiveFS.c"
 
 
+#define DESCRIPTOR_TESTS 0
+// set to 1 to enable descriptor tests
+
 #define assert(e) ((e) ? (true) : \
                    (fprintf(stderr,"%s,%d: assertion '%s' failed\n",__FILE__, __LINE__, #e), \
-                    fflush(stdout), abort()))
+                    fflush(stderr), fflush(stdout), abort()))
 
 /*
-
     int fs_format(const char *const fname);
     1   Normal
     2   NULL
     3   Empty string
-
     F15FS_t *fs_mount(const char *const fname);
     1   Normal
     2   NULL
     3   Empty string
-
     int fs_unmount(F15FS_t *fs);
     1   Normal
     2   NULL
-    
+    int fs_create_file(F15FS_t *const fs, const char *const fname, const ftype_t ftype);
+    1. Normal, file, in root
+    2. Normal, directory, in root
+    3. Normal, file, not in root
+    4. Normal, directory, not in root
+    5. Error, NULL fs
+    6. Error, NULL fname
+    7. Error, empty fname
+    8. Error, bad type
+    9. Error, path does not exist
+    10. Error, Root clobber
+    11. Error, directory exists
+    12. Error, file exists
+    13. Error, part of path not directory
+    14. Error, path terminal not directory
+    15. Error, path string has no leading slash
+    16. Error, path has trailing slash (no name for desired file)
+    17. Error, bad path, path part too long (will fail right now?)
+    18. Error, bad path, desired filename too long
+    19. Error, directory full.
+    20. Error, out of inodes.
+    21. Error, out of data blocks & file is directory (requires functional write)
+    int fs_get_dir(const F15FS_t *const fs, const char *const fname, dir_rec_t *const records)
+    1. Normal, root I guess?
+    2. Normal, subdir somewhere
+    3. Normal, empty dir
+    4. Error, empty fname
+    5. Error, NULL fname
+    6. Error, NULL fs
+    7. Error, NULL records
+    8. Error, not a directory
+    int fs_open_file(F15FS_t *const fs, const char * const fname)
+    1. Normal, file at root
+    2. Normal, file in subdir
+    3. Normal, multiple fd to the same file
+    4. Error, NULL fs
+    5. Error, NULL fname
+    6. Error, empty fname
+    7. Error, not a regular file
+    8. Error, file does not exist
+    9. Error, out of descriptors
+    ssize_t fs_write_file(F15FS_t *const fs, const char *const fname, const void *data, size_t nbyte, size_t offset)
+    1. Normal, in a subdir, 0 size to < 1 block
+    2. Normal, in a subdir, < 1 block to next (also, test offset below size of file)
+    3. Normal, in a subdir, 0 size to 1 block
+    4. Normal, in a subdir, 1 block to next
+    5. Normal, in a subdir, 1 block to partial
+    6. Normal, in a subdir, direct -> indirect
+    7. Normal, in a subdir, indirect -> dbl_indirect
+    8. Normal, in a subdir, full file (run out of blocks before max file size :/ )
+    9. Error, file full/blocks full (also test fs_create_file 13)
+    10. Error, file does not exist
+    11. Error, file is a directory
+    12. Error, nbyte + offset rollover
+    13. Error, fs NULL
+    14. Error, fname NULL
+    15. Error, fname empty
+    16. Error, data NULL
+    17. Error, nbyte 0 (not an error...? Bad parameters? Hmm.)
+    18. Error, offset past end of file
+    ssize_t fs_write_file(F15FS_t *const fs, const int fd, const void *data, size_t nbyte);
+    1. Normal, in a subdir, 0 size to < 1 block
+    2. Normal, in a subdir, < 1 block to next
+    3. Normal, in a subdir, 0 size to 1 block
+    4. Normal, in a subdir, 1 block to next
+    5. Normal, in a subdir, 1 block to partial
+    6. Normal, in a subdir, direct -> indirect
+    7. Normal, in a subdir, indirect -> dbl_indirect
+    8. Normal, in a subdir, full file (run out of blocks before max file size :/ )
+    9. Error, file full/blocks full (also test fs_create_file 13)
+    10. Error, nbyte + position rollover
+    11. Error, fs NULL
+    12. Error, data NULL
+    13. Error, nbyte 0 (not an error...? Bad parameters? Hmm.)
+    14. Error, bad fd
+    ssize_t fs_read_file(F15FS_t *const fs, const char *const fname, void *data, size_t nbyte, size_t offset);
+    1. Normal, subdir, begin to < 1 block
+    2. Normal, subdir, < 1 block to part of next
+    3. Normal, subdir, whole block
+    4. Normal, subdir, multiple blocks
+    5. Normal, subdir, direct->indirect transition
+    6. Normal, subdir, indirect->dbl_indirect transition
+    7. Error, file does not exist
+    8. Error, file not a regular file
+    9. Error, NULL fs
+    10. Error, NULL fname
+    11. Error, empty fname
+    12. Error, NULL data
+    13. Error, nbyte 0 (not an error?)
+    14. Error, offset well past EOF
+    15. Error, offset AT EOF
+    ssize_t fs_read_file(F15FS_t *const fs, const int fd, void *data, size_t nbyte);
+    1. Normal, subdir, begin to < 1 block
+    2. Normal, subdir, < 1 block to part of next
+    3. Normal, subdir, whole block
+    4. Normal, subdir, multiple blocks
+    5. Normal, subdir, direct->indirect transition
+    6. Normal, subdir, indirect->dbl_indirect transition
+    7. Error, NULL fs
+    8. Error, NULL data
+    9. Error, nbyte 0 (not an error?)
+    10. Error, at EOF (not an error?)
 */
 
 // SIZES AND CREATION/MOUNT/UNMOUNT
-void basic_tests_a();
+void tests_a();
+void test_sam();
+// CREATE FILE
+void tests_b();
+
+// FS_GET_DIR
+void tests_c();
 
+#if DESCRIPTOR_TESTS
 
-void basic_tests_b();
+    // FS_OPEN_FILE
+    void tests_d();
 
+#endif
 
-void basic_tests_c();
+// FS_WRITE_FILE
+void tests_e();
 
+// FS_READ_FILE
+void tests_f();
 
-void basic_tests_d();
 
 int main() {
 
-    puts("Running autotests, sit back and relax, it'll be awhile...");
+    puts("Running autotests, sit back and relax, it'll be awhile...\n");
+    //test_sam();
+    tests_a();
 
-    basic_tests_a();
+    puts("\n\nA tests passed...\n");
 
-    //puts("A tests passed...");
+    tests_b();
 
-    //basic_tests_b();
+    puts("\n\nB tests passed...\n");
 
-    //puts("B tests passed...");
+    tests_c();
 
-    //basic_tests_c();
+    puts("\n\nC tests passed...\n");
 
-    //puts("C tests passed...");
+    #if DESCRIPTOR_TESTS
+    tests_d();
 
-    //basic_tests_d();
+    puts("\n\nD tests passed...\n");
+    #endif
 
-    //puts("D tests passed...");
+    tests_e();
+
+    puts("\n\nE tests passed...\n");
+
+    tests_f();
+
+    puts("\n\nF tests passed...\n");
 
     puts("TESTS COMPLETE");
 
 }
 
-void basic_tests_a() {
+void test_sam(){
+    char *test_fname = "a_tests.f15fs";
+    assert(fs_format(test_fname) == 0);
+    F15FS_t *fs = fs_mount(test_fname);
+    assert(fs);
+
+    const char *(filenames[3]) = {
+        "/file", "/folder", "/folder/with_file"};
+
+    char **pathListOutput = NULL;
+
+    parseFilePath(filenames[0], &pathListOutput);
+    int size = (int)*pathListOutput[0];
+    int i = 1;
+    for(;i<size+1;i++){
+        printf("the string: %s\n",pathListOutput[i]);
+    }
+
+    printf("create folder result %d\n",fs_create_file(fs, filenames[1], DIRECTORY));
+    printf("filename of folder: %s\n",fs->inodeTable[1].fname);
+    printf("\n\n");
+    printf("create file result %d\n",fs_create_file(fs, filenames[2], REGULAR));
+    printf("filename of file: %s\n",fs->inodeTable[2].fname);
+    
+
+    assert(fs_unmount(fs) == 0);
+
+}
+
+void tests_a() {
+
+    char *test_fname = "a_tests.f15fs";
 
-    // I heavily suggest you assert your struct sizes here
+    /*
+        assert(sizeof(mdata_t) == 48);
+        assert(sizeof(inode_t) == 128);
+        assert(sizeof(data_block_t) == 1024);
+        assert(sizeof(dir_ent_t) == 49);
+        assert(sizeof(dir_mdata_t) == 44);
+        assert(sizeof(dir_block_t) == 1024);
+    */
 
     // FORMAT 1
-    assert(fs_format("TESTFILE.f15fs") == 0);
+    assert(fs_format(test_fname) == 0);
     // FORMAT 2
     assert(fs_format(NULL) < 0);
     // FORMAT 3
     assert(fs_format("") < 0);
 
     // MOUNT 1
-    F15FS_t *fs = fs_mount("TESTFILE.f15fs");
+    F15FS_t *fs = fs_mount(test_fname);
     assert(fs);
     // MOUNT 2
     assert(fs_mount(NULL) == NULL);
@@ -89,17 +249,684 @@ void basic_tests_a() {
 
 }
 
+// CREATE_FILE
+void tests_b() {
+    const char *(filenames[13]) = {
+        "/file", "/folder", "/folder/with_file", "/folder/with_folder",
+        "/DOESNOTEXIST", "/file/BAD_REQUEST", "/DOESNOTEXIST/with_file", "/folder/with_file/bad_req",
+        "folder/missing_slash", "/folder/new_folder/", "/folder/withwaytoolongfilenamethattakesupmorespacethanitshould/bad_req",
+        "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig", "/"
+    };
+
+    const char *(test_fname[2]) = {"b_tests_normal.f15fs", "b_tests_full_table.f15fs"};
+
+    assert(fs_format(test_fname[0]) == 0);
+
+    F15FS_t *fs = fs_mount(test_fname[0]);
+
+    assert(fs);
+    printf("\n\n\n\n");
+    // CREATE_FILE 1
+    assert(fs_create_file(fs, filenames[0], REGULAR) == 0);
+    printf("\n\n\n\n");
+    // CREATE_FILE 2
+    assert(fs_create_file(fs, filenames[1], DIRECTORY) == 0);
+
+    printf("\n\n\n\n\n\n");
+    // CREATE_FILE 3
+    assert(fs_create_file(fs, filenames[2], REGULAR) == 0);
+
+    // CREATE_FILE 4
+    assert(fs_create_file(fs, filenames[3], DIRECTORY) == 0);
+
+    // CREATE_FILE 5
+    assert(fs_create_file(NULL, filenames[4], REGULAR) < 0);
+
+    // CREATE_FILE 6
+    assert(fs_create_file(fs, NULL, REGULAR) < 0);
+
+    // CREATE_FILE 7
+    assert(fs_create_file(fs, "", REGULAR) < 0);
+
+    // CREATE_FILE 8
+    assert(fs_create_file(fs, "", 44) < 0);
+
+    // CREATE_FILE 9
+    assert(fs_create_file(fs, filenames[6], REGULAR) < 0);
+
+    // CREATE_FILE 10
+    assert(fs_create_file(fs, filenames[12], DIRECTORY) < 0);
+
+    // CREATE_FILE 11
+    assert(fs_create_file(fs, filenames[1], DIRECTORY) < 0);
+    assert(fs_create_file(fs, filenames[1], REGULAR) < 0);
+
+    // CREATE_FILE 12
+    assert(fs_create_file(fs, filenames[0], REGULAR) < 0);
+    assert(fs_create_file(fs, filenames[0], DIRECTORY) < 0);
+
+    // CREATE_FILE 13
+    assert(fs_create_file(fs, filenames[5], REGULAR) < 0);
+
+    // CREATE_FILE 14
+    assert(fs_create_file(fs, filenames[7], REGULAR) < 0);
+
+    // CREATE_FILE 15
+    //assert(fs_create_file(fs, filenames[8], REGULAR) < 0);
+    // Hmm, because of the way strtok works, this fails.
+    // But if we don't support relative paths, is there a reason to force abolute notation?
+    // It's really a semi-arbitrary restriction
+    // I suppose relative paths are up to the implementation, since . and .. are just special folder entires
+    // but that would mess with the directory content total, BUT extra parsing can work around that.
+    // Hmmmm.
+
+    // CREATE_FILE 16
+    assert(fs_create_file(fs, filenames[9], DIRECTORY) < 0);
+
+    // CREATE_FILE 17
+    assert(fs_create_file(fs, filenames[10], REGULAR) < 0);
+
+    // CREATE_FILE 18
+    assert(fs_create_file(fs, filenames[11], REGULAR) < 0);
+
+    // CREATE_FILE 19 - OUT OF INODES (and test 18 along the way)
+    // Gotta make... Uhh... A bunch of files. (255, but we'll need directories to hold them as well)
+    // Closing this file now for inspection to make sure these tests didn't mess it up
+    // There should be... 3 allocated data blocks and 5 inodes in use
+
+    fs_unmount(fs);
+
+    assert(fs_format(test_fname[1]) == 0);
+
+    fs = fs_mount(test_fname[1]);
+
+    assert(fs);
+
+    {
+        //puts("Attempting to fill inode table...");
+
+        // Dummy string to loop with
+        char fname[] = "/a/a";
+        // If we do basic a-z, with a-z contained in each, that's... 26*20 which is ~2x as much as we need
+        // Gotta do the math on when this should fail to set the right bounds
+
+        // 12 dirs of 20, remainder is... 3 inodes (dir and 2 files)
+        for (char dir = 'a'; dir < 'm'; fname[1] = ++dir) {
+            fname[2] = '\0';
+            assert(fs_create_file(fs, fname, DIRECTORY) == 0);
+            //printf("File: %s\n",fname);
+            fname[2] = '/';
+            for (char file = 'a'; file < 'u'; fname[3] = ++file) {
+                //printf("File: %s\n",fname);
+                assert(fs_create_file(fs, fname, REGULAR) == 0);
+            }
+        }
+
+        // CREATE_FILE 19
+        assert(fs_create_file(fs, "/a/z", REGULAR) < 0);
+
+        // Catch up to finish creation
+        fname[1] = 'm';
+        fname[2] = '\0';
+        //printf("File: %s\n",fname);
+        assert(fs_create_file(fs, fname, DIRECTORY) == 0);
+
+        fname[2] = '/';
+        fname[3] = 'a';
+        //printf("File: %s\n",fname);
+        assert(fs_create_file(fs, fname, REGULAR) == 0);
+
+        fname[3] = 'b';
+        //printf("File: %s\n",fname);
+        //assert(fs_create_file(fs, fname, REGULAR) == 0);
+        //puts("Inode table full?");
+
+        // This should fail, no more inodes.
+        // CREATE_FILE 20
+        fname[3] = 'c';
+        assert(fs_create_file(fs, fname, REGULAR) < 0);
+
+    }
+    // save file for inspection
+    fs_unmount(fs);
+
+    // ... Can't really test 20 yet.
+}
+
+void print_dir_records(const char *const fname, const dir_rec_t *const records) {
+    if (fname && records) {
+        printf("\n*** DIRECTORY RECORD ***\n");
+        printf("* DIRECTORY: %s\n", fname);
+        printf("* ENTRIES: %d\n", records->total);
+        for (unsigned i = 0; i < records->total; ++i) {
+            printf("* %d:\t%s - %s\n", i, records->contents[i].fname,
+                   ((records->contents[i].ftype == REGULAR) ? "REGULAR" :
+                    ((records->contents[i].ftype == DIRECTORY) ? "DIRECTORY" :
+                     "UNKNOWN")));
+        }
+        printf("****** RECORD END ******\n\n");
+        return;
+    }
+    assert(false /* tester broken? */);
+}
+
+bool check_record_for_file(const char *const fname, const ftype_t ftype, const dir_rec_t *const records) {
+    if (fname && records) {
+        for (unsigned i = 0; i < records->total; ++i) {
+            // Technically this may be risky since strncmp
+            // Doesn't say when it will stop
+            // and fname probably won't be FNAME_MAX in length
+            // But at least my fname will be properly terminated
+            // So it should cause strncmp to stop first
+            if (strncmp(records->contents[i].fname, fname, FNAME_MAX) == 0) {
+                return (records->contents[i].ftype == ftype);
+            }
+        }
+        return false;
+    } else {
+        assert(false /* tester broken? */);
+    }
+}
+
+// FS_GET_DIR
+void tests_c() {
+
+    // We'll ref the files from the b tests, but copy them over first
+    // Just in case it changes anything
+    assert(system("cp b_tests_normal.f15fs c_tests_normal.f15fs") == 0);
+    const char *test_fname = "c_tests_normal.f15fs";
+    const char *(filenames[13]) = {
+        "/file", "/folder", "/folder/with_file", "/folder/with_folder",
+        "/DOESNOTEXIST", "/file/BAD_REQUEST", "/DOESNOTEXIST/with_file", "/folder/with_file/bad_req",
+        "folder/missing_slash", "/folder/new_folder/", "/folder/withwaytoolongfilenamethattakesupmorespacethanitshould/bad_req",
+        "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig", "/"
+    };
+
+    F15FS_t *fs = fs_mount(test_fname);
+    // This should have root, folder, file, folder/with_file, folder/with_folder
+
+    dir_rec_t record_struct;
+    // FS_GET_DIR 1
+    assert(fs_get_dir(fs, filenames[12], &record_struct) == 0);
+    print_dir_records(filenames[12], &record_struct);
+    assert(record_struct.total == 2);
+    assert(check_record_for_file(strrchr(filenames[0], '/') + 1, REGULAR, &record_struct));
+    assert(check_record_for_file(strrchr(filenames[1], '/') + 1, DIRECTORY, &record_struct));
+
+    // FS_GET_DIR 2
+    assert(fs_get_dir(fs, filenames[1], &record_struct) == 0);
+    print_dir_records(filenames[1], &record_struct);
+    assert(record_struct.total == 2);
+    assert(check_record_for_file(strrchr(filenames[2], '/') + 1, REGULAR, &record_struct));
+    assert(check_record_for_file(strrchr(filenames[3], '/') + 1, DIRECTORY, &record_struct));
+
+    // FS_GET_DIR 3
+    assert(fs_get_dir(fs, filenames[3], &record_struct) == 0);
+    print_dir_records(filenames[3], &record_struct);
+    assert(record_struct.total == 0);
+
+    // FS_GET_DIR 4
+    assert(fs_get_dir(fs, "", &record_struct) < 0);
+
+    // FS_GET_DIR 5
+    assert(fs_get_dir(fs, NULL, &record_struct) < 0);
+
+    // FS_GET_DIR 6
+    assert(fs_get_dir(NULL, filenames[12], &record_struct) < 0);
+
+    // FS_GET_DIR 7
+    assert(fs_get_dir(fs, filenames[12], NULL) < 0);
+
+    // FS_GET_DIR 8
+    assert(fs_get_dir(fs, filenames[0], &record_struct) < 0);
+
+    assert(fs_unmount(fs) == 0);
+}
+
+#if DESCRIPTOR_TESTS
+
+// FS_OPEN_FILE
+void tests_d() {
+    // Once again, just borrow B's file.
+    assert(system("cp b_tests_normal.f15fs d_tests.f15fs") == 0);
+
+    const char *test_fname = "d_tests.f15fs";
+    const char *(filenames[13]) = {
+        "/file", "/folder", "/folder/with_file", "/folder/with_folder",
+        "/DOESNOTEXIST", "/file/BAD_REQUEST", "/DOESNOTEXIST/with_file", "/folder/with_file/bad_req",
+        "folder/missing_slash", "/folder/new_folder/", "/folder/withwaytoolongfilenamethattakesupmorespacethanitshould/bad_req",
+        "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig", "/"
+    };
+
+    F15FS_t *fs = fs_mount(test_fname);
+    assert(fs);
+
+    // FS_OPEN_FILE 1
+    assert(fs_open_file(fs, filenames[0]) >= 0);
+
+    // FS_OPEN_FILE 2
+    assert(fs_open_file(fs, filenames[2]) >= 0);
+
+    // FS_OPEN_FILE 3
+    assert(fs_open_file(fs, filenames[2]) >= 0);
+
+    // FS_OPEN_FILE 4
+    assert(fs_open_file(NULL, filenames[2]) < 0);
+
+    // FS_OPEN_FILE 5
+    assert(fs_open_file(fs, NULL) < 0);
+
+    // FS_OPEN_FILE 6
+    assert(fs_open_file(fs, "") < 0);
+
+    // FS_OPEN_FILE 7
+    assert(fs_open_file(fs, filenames[1]) < 0);
+
+    // FS_OPEN_FILE 8
+    assert(fs_open_file(fs, filenames[4]) < 0);
+
+    // FS_OPEN_FILE 9
+    // we have... 3 open so far
+    for (unsigned i = 3; i < 256; ++i) {
+        assert(fs_open_file(fs, filenames[2]) >= 0);
+    }
+    // So this should fail
+    assert(fs_open_file(fs, filenames[2]) < 0);
+
+    assert(fs_unmount(fs));
+
+}
+
+// FS_WRITE_FILE - DESCRIPTOR
+void tests_e() {
+    // Terrible tests for a terrible function
+
+    // Once again, just borrow B's file.
+    assert(system("cp b_tests_normal.f15fs e_tests_normal.f15fs") == 0);
+
+    const char *(test_fname[2]) = {"e_tests_normal.f15fs", "e_tests_full.f15fs"};
+    const char *(filenames[13]) = {
+        "/file", "/folder", "/folder/with_file", "/folder/with_folder",
+        "/DOESNOTEXIST", "/file/BAD_REQUEST", "/DOESNOTEXIST/with_file", "/folder/with_file/bad_req",
+        "folder/missing_slash", "/folder/new_folder/", "/folder/withwaytoolongfilenamethattakesupmorespacethanitshould/bad_req",
+        "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig", "/"
+    };
+
+    F15FS_t *fs = fs_mount(test_fname[0]);
+    assert(fs);
+
+    uint8_t file_data[4096];
+    memset(file_data, 1, 4096);
+
+
+    int fd;
+    fd = fs_open_file(fs, filenames[2]);
+    assert(fd >= 0);
+
+    // FS_WRITE_FILE 1
+    assert(fs_write_file(fs, fd, file_data, 300) == 300);
+
+    // FS_WRITE_FILE 2
+    assert(fs_write_file(fs, fs, file_data, 824, 200) == 824); // file[2] goes to 1024
+
+
+    fd = fs_open_file(fs, filenames[0]);
+    assert(fd >= 0);
+
+    // FS_WRITE_FILE 3
+    assert(fs_write_file(fs, fd, file_data, 1024) == 1024); // file[0] goes to 1024
+
+    // FS_WRITE_FILE 4
+    assert(fs_write_file(fs, fd, file_data, 1024) == 1024); // file[0] goes to 2048 now
+
+    // FS_WRITE_FILE 5
+    assert(fs_write_file(fs, fd, file_data, 300) == 300); // file[2] goes to 2348 now
+
+    // FS_WRITE_FILE 6
+    assert(fs_write_file(fs, fd, file_data, 4095) == 4095); // file[0] goes to 6143 now, 1 before end of directs
+    assert(fs_write_file(fs, fd, file_data, 1025) == 1025); // file[0] goes to 7168, 1 block into indirect
+
+    // FS_WRITE_FILE 7
+    // Need to fill out... 256 more blocks to put us 1 into double indirect
+    for (int i = 0; i < 256; ++i) {
+        assert(fs_write_file(fs, fd, file_data, 1024) == 1024);
+    }
+    // File's into double indirect
+
+    fs_unmount(fs);
+
+    assert(fs_format(filenames[1]) == 0);
+    fs = fs_mount(filenames[1]);
+    assert(fs);
+
+    assert(fs_create_file(fs, filenames[0], REGULAR) == 0);
+
+    fd = fs_open_file(fs, filenames[0]);
+    assert(fd >= 0);
+
+    // Going to fill the fs with a single file
+    for (unsigned i = 0; i < 65239; ++i) {
+        assert(fs_write_file(fs, fd, file_data) == 1024);
+    }
+    // File system is now FULL.
+    // Throw in that test for FS_CREATE_FILE
+
+    // FS_CREATE_FILE 13
+    assert(fs_create_file(fs, filenames[1], DIRECTORY) < 0);
+
+    // FS_WRITE_FILE 9
+    assert(fs_write_file(fs, fd, file_data, 1024) < 0); // out of room should be an error, not a 0 written
+
+    assert(fs_unmount(fs) == 0);
+
+    fs = fs_mount(test_fname[0]);
+    assert(fs);
+
+    fd = fs_open_file(fs, filenames[2]);
+    assert(fd >= 0);
+
+    // FS_WRITE_FILE 10
+    assert(fs_write_file(fs, fd, file_data, 1024) == 1024);
+    assert(fs_write_file(fs, fd, file_data, SIZE_MAX - 512) == 1024);
+
+    // FS_WRITE_FILE 11
+    fd = fs_open_file(filenames[2]);
+    assert(fd >= 0);
+    assert(fs_write_file(NULL, fd, file_data, 300) < 0);
+
+    // FS_WRITE_FILE 12
+    assert(fs_write_file(fs, fd, NULL, 300, 0) < 0);
+
+    // FS_WRITE_FILE 13
+    assert(fs_write_file(fs, fd, file_data, 0) <= 0); // Allow an error or 0 written
+
+    // FS_WRITE_FILE 14
+    assert(fs_write_file(fs, 9999, file_data, 0) < 0);
+
+    assert(fs_unmount(fs) == 0);
+
+}
+
+// FS_READ_FILE - DESCRIPTOR
+void tests_f() {
+
+    assert(system("cp e_tests_normal.f15fs f_tests_normal.f15fs") == 0);
+
+    const char *test_fname = "f_tests_normal.f15fs";
+    const char *(filenames[13]) = {
+        "/file", "/folder", "/folder/with_file", "/folder/with_folder",
+        "/DOESNOTEXIST", "/file/BAD_REQUEST", "/DOESNOTEXIST/with_file", "/folder/with_file/bad_req",
+        "folder/missing_slash", "/folder/new_folder/", "/folder/withwaytoolongfilenamethattakesupmorespacethanitshould/bad_req",
+        "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig", "/"
+    };
+
+    // file 0 should go into double_indirect, file 2 goes to 1024
+
+    F15FS_t *fs = fs_mount(test_fname);
+    assert(fs);
+
+    uint8_t read_space[4096];
+    uint8_t check_val[4096];
+    memset(check_val, 1, 4096); // Didn't actually write any other values
+
+
+    int fd[2];
+    fd[0] = fs_open_file(fs, filenames[0]);
+    fd[1] = fs_open_file(fs, filenames[2]);
+    assert(fd[0] >= 0);
+    assert(fd[1] >= 0);
+
+    // FS_READ_FILE 1
+    assert(fs_read_file(fs, fd[1], read_space, 300) == 300);
+    assert(memcmp(read_space, check_val, 300) == 0);
+
+    // FS_READ_FILE 2
+    assert(fs_read_file(fs, fd[0], read_space, 512) == 512);
+    assert(fs_read_file(fs, fd[0], read_space, 1024) == 1024);
+    assert(memcmp(read_space, check_val, 1536) == 0);
+
+    assert(fs_read_file(fs, fd[0], read_space, 512) == 512); // jump to end of block for other tests
+
+    // FS_READ_FILE 3
+    assert(fs_read_file(fs, fd[0], read_space, 1024) == 1024);
+    assert(memcmp(read_space, check_val, 1024) == 0);
+
+    // FS_READ_FILE 4
+    assert(fs_read_file(fs, fd[0], read_space, 2048) == 2048);
+    assert(memcmp(read_space, check_val, 2048) == 0);
+
+    // FS_READ_FILE 5
+    assert(fs_read_file(fs, fd[0], read_space, 2048) == 2048);
+    assert(memcmp(read_space, check_val, 2048) == 0);
+
+    // we have read 7 blocks. we have to jump ahead... 254 and then, eh, 1.5
+    for (unsigned i = 0; i < 254; ++i) {
+        assert(fs_read_file(fs, fd[0], read_space, 1024) == 1024);
+        assert(memcmp(read_space, check_val, 1024) == 0);
+    }
+
+    // FS_READ_FILE 6
+    assert(fs_read_file(fs, fd[0], read_space, 1536) == 1536);
+    assert(memcmp(read_space, check_val, 1536) == 0);
+
+    // FS_READ_FILE 7
+    assert(fs_read_file(NULL, fd[0], read_space, 10) < 0);
 
-void basic_tests_b() {
+    // FS_READ_FILE 8
+    assert(fs_read_file(fs, fd[0], NULL, 10, 0) < 0);
+
+    // FS_READ_FILE 9
+    assert(fs_read_file(fs, fd[0], read_space, 0) <= 0);
+
+    // FS_READ_FILE 10
+    // I've actually sortof lost track, but we should be within 4 blocks of then end (should be 512B left?)
+    // Request 4 blocks, that should get us to EOF, then request more.
+    assert(fs_read_file(fs, fd[0], read_space, 4096) > 0);
+    // This shoudl fail, or return 0
+    assert(fs_read_file(fs, fd[0], read_space, 4096) <= 0);
+
+    assert(fs_unmount(fs) == 0);
 
 }
 
+#else
+
+
+// FS_WRITE_FILE
+void tests_e() {
+    // Terrible tests for a terrible function
+
+
+    // Once again, just borrow B's file.
+    assert(system("cp b_tests_normal.f15fs e_tests_normal.f15fs") == 0);
+
+    const char *(test_fname[2]) = {"e_tests_normal.f15fs", "e_tests_full.f15fs"};
+    const char *(filenames[13]) = {
+        "/file", "/folder", "/folder/with_file", "/folder/with_folder",
+        "/DOESNOTEXIST", "/file/BAD_REQUEST", "/DOESNOTEXIST/with_file", "/folder/with_file/bad_req",
+        "folder/missing_slash", "/folder/new_folder/", "/folder/withwaytoolongfilenamethattakesupmorespacethanitshould/bad_req",
+        "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig", "/"
+    };
+
+    F15FS_t *fs = fs_mount(test_fname[0]);
+    assert(fs);
+
+    uint8_t file_data[4096];
+    memset(file_data, 1, 4096);
 
-void basic_tests_c() {
+
+    // FS_WRITE_FILE 1
+    assert(fs_write_file(fs, filenames[2], file_data, 300, 0) == 300);
+
+    // FS_WRITE_FILE 2
+    assert(fs_write_file(fs, filenames[2], file_data, 824, 200) == 824); // file[2] goes to 1024
+
+    // FS_WRITE_FILE 3
+    assert(fs_write_file(fs, filenames[0], file_data, 1024, 0) == 1024); // file[0] goes to 1024
+
+    // FS_WRITE_FILE 4
+    assert(fs_write_file(fs, filenames[0], file_data, 1024, 1024) == 1024); // file[0] goes to 2048 now
+
+    // FS_WRITE_FILE 5
+    assert(fs_write_file(fs, filenames[0], file_data, 300, 2048) == 300); // file[0] goes to 2348 now
+
+    // FS_WRITE_FILE 6
+    assert(fs_write_file(fs, filenames[0], file_data, 3795, 2048) == 3795); // file[0] goes to 6143 now, 1 before end of directs
+    assert(fs_write_file(fs, filenames[0], file_data, 1025, 6143) == 1025); // file[0] goes to 7168, 1 block into indirect
+
+    // FS_WRITE_FILE 7
+    for (int i = 0; i < 256; ++i) {
+        assert(fs_write_file(fs, filenames[0], file_data, 1024, 7168 + i * 1024) == 1024);
+    }
+    // File's one block into double indirect
+
+    fs_unmount(fs);
+
+    assert(fs_format(test_fname[1]) == 0);
+    fs = fs_mount(test_fname[1]);
+    assert(fs);
+
+    assert(fs_create_file(fs, filenames[0], REGULAR) == 0);
+
+    // Going to fill the fs with a single file
+    // That's 65239 blocks worth of file data
+    // A file can hold 65798 blocks, but we have less in the block store
+    // AND indirects and double indirects take up space
+    // so it comes up to fewer blocks than you'd expect. A fresh F15FS has 65536 - 41 free (65495)
+    // We get 6 directs through our inode, so 6 file blocks, 65489 free
+    // now we have to start allocating indirects. We get one indirect in out inode, and it gives us 256 blocks
+    // 262 file blocks, 1 overhead, 65232 free
+    // Now we make our double indirect (and others, but taking this in steps), it is an overhead of 1 for 256 indirects
+    // 262 file, 2 overhead, 65231 free
+    // From here we have room for 256 indirects, each indirect taking 256 file blocks, and 1 overhead
+    // 256 * 257 is 65792, though, so we don't max out the double indirect
+    // 65231/257 = 253.81, so we get 254 indirects, but one isn't completely full
+    // Not counting the contents of the partially filled indirect (but counting the indirect itself), we have
+    // 65030 file blocks, 256 overhead, and 209 free, which goes in that last indirect, so in total, one file can take up
+    // 65239 file blocks, with 256 overhead, and 0 free blocks remaining
+
+    for (unsigned i = 0; i < 65239; ++i) {
+        assert(fs_write_file(fs, filenames[0], file_data, 1024, i * 1024) == 1024);
+    }
+    // File system is now FULL.
+    // Throw in that test for FS_CREATE_FILE
+
+    // FS_CREATE_FILE 13
+    assert(fs_create_file(fs, filenames[1], DIRECTORY) < 0);
+
+    // FS_WRITE_FILE 9
+    assert(fs_write_file(fs, filenames[0], file_data, 1024, 65495 * 1024) < 0); // out of room should be an error, not a 0 written
+
+    assert(fs_unmount(fs) == 0);
+
+    fs = fs_mount(test_fname[0]);
+    assert(fs);
+
+    // FS_WRITE_FILE 10
+    assert(fs_write_file(fs, filenames[4], file_data, 300, 0) < 0);
+
+    // FS_WRITE_FILE 11
+    assert(fs_write_file(fs, filenames[1], file_data, 300, 0) < 0);
+
+    // FS_WRITE_FILE 12
+    assert(fs_write_file(fs, filenames[2], file_data, SIZE_MAX - 3, 10) < 0);
+
+    // FS_WRITE_FILE 13
+    assert(fs_write_file(NULL, filenames[2], file_data, 300, 0) < 0);
+
+    // FS_WRITE_FILE 14
+    assert(fs_write_file(fs, NULL, file_data, 300, 0) < 0);
+
+    // FS_WRITE_FILE 15
+    assert(fs_write_file(fs, "", file_data, 300, 0) < 0);
+
+    // FS_WRITE_FILE 16
+    assert(fs_write_file(fs, filenames[2], NULL, 300, 0) < 0);
+
+    // FS_WRITE_FILE 17
+    assert(fs_write_file(fs, filenames[2], file_data, 0, 0) <= 0); // Allow an error or 0 written
+
+    // FS_WRITE_FILE 18
+    assert(fs_write_file(fs, filenames[2], file_data, 300, 4096) < 0);
+
+    assert(fs_unmount(fs) == 0);
 
 }
 
-void basic_tests_d() {
+// FS_READ_FILE
+void tests_f() {
+
+    assert(system("cp e_tests_normal.f15fs f_tests_normal.f15fs") == 0);
+
+    const char *test_fname = "f_tests_normal.f15fs";
+    const char *(filenames[13]) = {
+        "/file", "/folder", "/folder/with_file", "/folder/with_folder",
+        "/DOESNOTEXIST", "/file/BAD_REQUEST", "/DOESNOTEXIST/with_file", "/folder/with_file/bad_req",
+        "folder/missing_slash", "/folder/new_folder/", "/folder/withwaytoolongfilenamethattakesupmorespacethanitshould/bad_req",
+        "/folder/withfilethatiswayyyyytoolongwhydoyoumakefilesthataretoobig", "/"
+    };
+
+    // file 0 should go into double_indirect, file 2 goes to 1024
+
+    F15FS_t *fs = fs_mount(test_fname);
+    assert(fs);
+
+    uint8_t read_space[4096];
+    uint8_t check_val[4096];
+    memset(check_val, 1, 4096); // Didn't actually write any other values
+
+    // FS_READ_FILE 1
+    assert(fs_read_file(fs, filenames[2], read_space, 300, 0) == 300);
+    assert(memcmp(read_space, check_val, 300) == 0);
+
+    // FS_READ_FILE 2
+    assert(fs_read_file(fs, filenames[0], read_space, 1024, 512) == 1024);
+    assert(memcmp(read_space, check_val, 1024) == 0);
+
+    // FS_READ_FILE 3
+    assert(fs_read_file(fs, filenames[0], read_space, 1024, 1024) == 1024);
+    assert(memcmp(read_space, check_val, 1024) == 0);
+
+    // FS_READ_FILE 4
+    assert(fs_read_file(fs, filenames[0], read_space, 4096, 1024) == 4096);
+    assert(memcmp(read_space, check_val, 4096) == 0);
 
+    // FS_READ_FILE 5
+    assert(fs_read_file(fs, filenames[0], read_space, 4096, 4096) == 4096);
+    assert(memcmp(read_space, check_val, 4096) == 0);
+
+    // FS_READ_FILE 6
+    assert(fs_read_file(fs, filenames[0], read_space, 2048, 267264) == 2048);
+    assert(memcmp(read_space, check_val, 1024) == 0);
+
+    // FS_READ_FILE 7
+    assert(fs_read_file(fs, filenames[5], read_space, 300, 0) < 0);
+
+    // FS_READ_FILE 8
+    assert(fs_read_file(fs, filenames[1], read_space, 300, 0) < 0);
+
+    // FS_READ_FILE 9
+    assert(fs_read_file(NULL, filenames[0], read_space, 300, 0) < 0);
+
+    // FS_READ_FILE 10
+    assert(fs_read_file(fs, NULL, read_space, 300, 0) < 0);
+
+    // FS_READ_FILE 11
+    assert(fs_read_file(fs, "", read_space, 300, 0) < 0);
+
+    // FS_READ_FILE 12
+    assert(fs_read_file(fs, filenames[0], NULL, 300, 0) < 0);
+
+    // FS_READ_FILE 13
+    assert(fs_read_file(fs, filenames[0], read_space, 0, 0) <= 0);
+
+    // FS_READ_FILE 14
+    assert(fs_read_file(fs, filenames[2], NULL, 300, 4173) < 0);
+
+    // FS_READ_FILE 15
+    assert(fs_read_file(fs, filenames[0], NULL, 300, 1024) < 0);
+
+    assert(fs_unmount(fs) == 0);
 
 }
+#endif
\ No newline at end of file
